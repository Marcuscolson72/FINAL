<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slope Skateboard Game</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; background:#f4f7fb; text-align:center; padding:18px; }
    #gameCanvas { background: linear-gradient(#87cefa, #d0f7ff); border:2px solid #333; display:block; margin:12px auto; }
    .hidden { display:none; }
    input[type="number"], input[type="text"] { padding:6px; width:120px; margin:6px; }
    button { padding:8px 14px; margin:8px; cursor:pointer; }
    #hud { margin-top:8px; }
  </style>
</head>
<body>
  <h1>Slope Skateboard Game</h1>
  <p>Answer slope questions correctly to earn a shot. Land on the green platform to earn 100 points. Get to 500 to win.</p>

  <div id="questionBox">
    <h2 id="questionText">Question will appear here</h2>
    <input id="answerInput" type="text" placeholder="Enter slope (e.g. 2 or -0.5)" />
    <button id="submitAnswerBtn">Submit</button>
    <p id="feedback"></p>
  </div>

  <div id="gameBox" class="hidden">
    <h3>Adjust your shot</h3>
    <label>Shot slope:
      <input id="shotSlope" type="number" step="0.1" value="0.5" />
    </label>
    <label>Power:
      <input id="powerInput" type="number" step="0.1" min="0.5" max="2" value="1" />
    </label>
    <button id="takeShotBtn">Take Shot</button>
    <div id="hud">
      Points: <span id="points">0</span> / 500
    </div>
  </div>

  <canvas id="gameCanvas" width="700" height="320" class="hidden"></canvas>

<script>
/* ===== Slope Skateboard Game - Fixed & working =====
   Key fixes:
   - Animate until skateboard reaches platform x.
   - Ensure powerInput exists and is read.
   - Only play audio after a user gesture (we trigger sounds after they press buttons).
   - Random question generator every time.
*/

let points = 0;
const pointsEl = document.getElementById('points');
const qText = document.getElementById('questionText');
const fb = document.getElementById('feedback');
const gameBox = document.getElementById('gameBox');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const platform = { x: 450, y: 200, w: 80, h: 10, centerX: 450 + 80/2 };

// ensure user gesture allows sounds to play — we create audio objects but browsers only permit playback after a gesture.
let soundLand, soundMiss, soundLaunch;
function initSounds() {
  // create them when the user first interacts
  if (!soundLaunch) {
    soundLand = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
    soundMiss = new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg');
    soundLaunch = new Audio('https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_drum_hit.ogg');
    // reduce volume a bit
    soundLand.volume = 0.7;
    soundMiss.volume = 0.6;
    soundLaunch.volume = 0.6;
  }
}

// PARTICLES
const particles = [];
function spawnParticles(x,y,color='orange') {
  for (let i=0;i<22;i++){
    particles.push({
      x, y,
      vx: (Math.random()*4)-2,
      vy: (Math.random()*-4)-1,
      life: 36,
      color
    });
  }
}
function drawParticles() {
  for (let i = particles.length -1; i >= 0; i--) {
    const p = particles[i];
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 4, 4);
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.18; // gravity
    p.life--;
    if (p.life <= 0) particles.splice(i,1);
  }
}

// Random question generator (never returns run=0)
function generateQuestion() {
  const rise = Math.floor(Math.random()*11) - 5; // -5..5
  let run = Math.floor(Math.random()*9) + 1; // 1..9
  // occasionally negative run to produce negative slope? If you want negative run, uncomment:
  // if (Math.random() < 0.2) run = -run;
  return { rise, run };
}

let currentQ = null;
function newQuestion() {
  currentQ = generateQuestion();
  qText.textContent = `What is the slope of a line with rise ${currentQ.rise} and run ${currentQ.run}?`;
  document.getElementById('answerInput').value = '';
  fb.textContent = '';
  // hide game box until correct
  gameBox.classList.add('hidden');
  canvas.classList.add('hidden');
  drawScene(); // refresh scene (platform only)
}

// ANSWER CHECK
function checkAnswer() {
  initSounds(); // allow sounds after first user gesture
  const correct = currentQ.rise / currentQ.run;
  const userStr = document.getElementById('answerInput').value.trim();
  // try several number formats: allow fraction like "4/2"
  let user = NaN;
  if (userStr.includes('/')) {
    const parts = userStr.split('/');
    if (parts.length === 2) user = parseFloat(parts[0]) / parseFloat(parts[1]);
  } else {
    user = parseFloat(userStr);
  }
  if (!isFinite(user)) {
    fb.textContent = 'Enter a valid number (examples: 2, -1.5, 4/2).';
    return;
  }
  if (Math.abs(user - correct) < 0.001) {
    fb.textContent = 'Correct! You earned a shot!';
    gameBox.classList.remove('hidden');
    canvas.classList.remove('hidden');
    drawScene();
  } else {
    fb.textContent = 'Incorrect, try again.';
  }
}

// DRAW SCENE (platform + particles + ground lines)
function drawScene(skateX = null, skateY = null) {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background ground
  ctx.fillStyle = '#a2d18c';
  ctx.fillRect(0, 260, canvas.width, 60);

  // draw platform (green)
  ctx.fillStyle = 'green';
  ctx.fillRect(platform.x, platform.y, platform.w, platform.h);

  // platform border
  ctx.strokeStyle = '#0b6a0b';
  ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);

  // draw a ramp/guide from left start to the skate start (cosmetic)
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(50, 250);
  ctx.lineTo(50 + 140, 210);
  ctx.stroke();

  // particles under everything (they will appear before skateboard if not passed skate coords)
  drawParticles();

  // draw skateboard if given coordinates
  if (skateX !== null && skateY !== null) {
    // skateboard deck
    ctx.save();
    ctx.translate(skateX, skateY);
    ctx.fillStyle = '#b22222';
    ctx.fillRect(-18, -6, 36, 12); // deck
    // wheels
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(-10, 8, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(10, 8, 5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// ANIMATE SHOT
let animating = false;
function animateShot(slope, power, onComplete) {
  if (animating) return;
  animating = true;
  initSounds();
  if (soundLaunch) {
    try { soundLaunch.currentTime = 0; soundLaunch.play(); } catch(e){ /* ignore autoplay errors */ }
  }

  let x = 50;
  const startY = 250;

  // target x is center of platform
  const targetX = platform.centerX;
  // speed controls how many pixels per frame (higher -> faster)
  const speed = 4 + (power - 1) * 4;

  function frame() {
    // calculate y by simple linear relation: y = startY - slope * (x - 50) * power
    // (This is simplistic physics for easy control — modify for parabola if desired)
    const y = startY - slope * ((x - 50) * power);

    drawScene(x, y);

    // advance x
    x += speed;

    // when we've reached/passed platform center, check landing
    if (x >= targetX) {
      // landing Y at platform center
      const landingY = startY - slope * ((targetX - 50) * power);

      // check if landingY is close enough to platform height (platform top is platform.y)
      // small tolerance to allow 'land' area
      const platformTop = platform.y;
      const tolerance = 16; // pixels tolerance above/below platform top to count as a landing
      if (landingY >= platformTop - tolerance && landingY <= platformTop + tolerance) {
        // Landed!
        if (soundLand) { try { soundLand.currentTime = 0; soundLand.play(); } catch(e){} }
        spawnParticles(targetX, landingY, '#ffb84d');
        points += 100;
        pointsEl.textContent = points;
        setTimeout(()=>{ alert('Landed! +100 points'); }, 10);
      } else {
        // Missed
        if (soundMiss) { try { soundMiss.currentTime = 0; soundMiss.play(); } catch(e){} }
        spawnParticles(targetX, platformTop + 6, '#b0b0b0');
        setTimeout(()=>{ alert('Missed! Try again by answering a new question.'); }, 10);
      }

      animating = false;
      if (points >= 500) {
        setTimeout(()=> alert('You win!'), 30);
      }
      if (onComplete) onComplete();
      return;
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

/* ---------- Hook up UI ---------- */
document.getElementById('submitAnswerBtn').addEventListener('click', () => {
  checkAnswer();
});
document.getElementById('takeShotBtn').addEventListener('click', () => {
  // read inputs, validate, then animate
  const slope = parseFloat(document.getElementById('shotSlope').value);
  const powerVal = parseFloat(document.getElementById('powerInput').value);
  if (!isFinite(slope)) { alert('Enter a numeric slope for the shot.'); return; }
  if (!isFinite(powerVal) || powerVal <= 0) { alert('Enter a valid power value (>0).'); return; }

  // animate, then ask a new question at end
  animateShot(slope, powerVal, () => {
    // small delay to let particles/sound play
    setTimeout(newQuestion, 500);
  });
});

/* Start */
drawScene();
newQuestion();
</script>
</body>
</html>
